# Tetris-Game
This is a simple project which is based on MFC named Tetris.
基于MFC的经典俄罗斯方块游戏，采用C++面向对象方法结合简单图形学知识开发。

## 游戏界面 Game UI
![游戏界面](https://github.com/yocichenyx/Tetris-Game/blob/master/界面.png)

## 游戏过程
![Watch the video](https://github.com/yocichenyx/Tetris-Game/blob/master/GIF.gif)

## 前期设计：
类：面板类Panel、方块类Square、组合体类Assembly

类的关系：其中面板类只有一个实例，我将其设计成了单件，面板单件掌握组合体对象的引用，而每个组合体由多个小方块组成，故组合体掌握组成它的方块对象的引用。

## 关键算法的设计
>碰撞检测算法

我的设计是正在下落的当前焦点组合体是一种颜色而已经下落到达底部的组合体是另外的一种颜色，这样一来，就可以使用颜色的不同解决碰撞的检测。
具体做法：每次下落完成时，遍历焦点组合体的每个小方块对象，如果他的下方、左方或者右方出现不同的颜色且非背景色，那么我们可以认为已经发生了碰撞，进行相应的处理即可。
>满行消除算法

在下落到达底部的时候（在碰撞检测算法中，检测到下方障碍物）检测满行，进行消除。
具体做法：遍历组合体的每一个小方块对象所在的行，如果全都是一个颜色，那么我们可以认为改行可消除。我才用的消除算法是将改行填充背景色，再将上方的所有还存在的方块对象下移。
>方块旋转算法

俄罗斯方块的旋转很重要，但它的旋转实现起来并不简单。首先，需要进行计算，根据旋转方向的不同利用cos()sin()函数进行计算，但是我发现，计算之后得值会是一个double型的值，在赋值给整形点坐标会发生精度损失，且计算后的点也不会在我们预定的方格中心点上，这就需要“归位”。我使用的办法是，先绕着组合体中心点旋转，计算落点，然后将落点x, y坐标参照一个固定点，计算整数格子数，然后再加上半个格子即得到“准确的”旋转后的点。
>定时器逻辑设计

定时器逻辑，如果面板组合体vector为空，那么先生成一个，进入下落逻辑。定时，更新组合体坐标，刷新面板，实时捕获键盘操作，方向键↑那么进行旋转逻辑，左右和下，分别进行移动逻辑。到达底部，进行满行消除。到达顶部，进入结束逻辑。

## 遇到的问题
- 满行消除如何消除多行？
上述算法可以解决，我遍历了每个小方块所在的行，如果满行就进行消除。
- 方块对象最终的析构问题？
目前的逻辑是：在判定游戏结束时，析构所有的组合体对象，进而析构所有的方块。但在填充颜色（游戏结束会对目前的在面板中的方块统一填充一个颜色）时，会出现问题：有的方块已经被消除掉了，就不需要再对它进行涂色，然而无法确定方块是否被消掉。我的想法是，给每个方块添加一个属性，标志它是否还有效，在填充时进行判断，如果还有效进行填充，否则，不填充，这样可以防止游戏莫名的崩溃。

